# Tree #

## Definition ##

**Binary Tree**
<br/>
Each node has at most two children

**Binary Search Tree**
<br/>
A binary tree; left-subtree's nodes are smaller than root, right-subtrees' nodes are larger than root

**Balanced/Unbalanced Tree**
<br/>
Balanced vs. Unbalanced: In a balanced tree, the depth of the left and right subtrees of every node differ by 1 or less.

**Full Binary Tree**
<br/>
Every node other than the leaves has two children.

**Perfect Binary Tree**
<br/>
All leaves are at the same depth or same level, and every parent has two children.

**Complete Binary Tree**
<br/>
Every level, except possibly the last, is completely filled, and all nodes are as far left as possible.

![binary tree](/img/binary-tree.png)

## Depth First Search ##
* pre-order traversal
* in-order traversal
* post-order traversal

**Recursively implementation**
```
// pre-order traversal using recursion
public void RecDFS(TreeNode root) {
  if (root == null) return;
  access(root.val);
  RecDFS(root.left);
  RecDFS(root.right);
}

// in-order traversal using recursion
public void RecDFS(TreeNode root) {
  if (root == null) return;
  RecDFS(root.left);
  access(root.val);
  RecDFS(root.right);
}

// post-order traversal using recursion
public void RecDFS(TreeNode root) {
  if (root == null) return;
  RecDFS(root.left);
  RecDFS(root.right);
  access(root.val);
}
```
**Iteratively implementation**
(Using Stack!)

pre-order
```
// pre-order traversal using iteration 1
public void ItePDFS(TreeNode root) {
  if (root==null) return;
  Stack<TreeNode> s = new Stack<TreeNode>();
  s.push(root);
  TreeNode cur;

  while (!s.isEmpty()) {
    cur = s.pop();
    print(cur.val);
    if (cur.right!=null) s.push(cur.right);  // first push right, then left!!!
    if (cur.left!=null) s.push(cur.left);
  }
}
```

in-order
```
// in-order traversal using iteration
iterativeInorder(node)
  parentStack = empty stack
  while (! parentStack.isEmpty() or node ≠ null)
    if (node ≠ null)
      parentStack.push(node)
      node = node.left
    else
      node = parentStack.pop()
      visit(node)
      node = node.right
```

post-order
```
// in this implementation, a node can be visited only if its right node is visited just before
iterativePostorder(node)
  s ← empty stack
  lastNodeVisited ← null
  while (not s.isEmpty() or node ≠ null)
    if (node ≠ null)
      s.push(node)
      node ← node.left
    else
      peekNode ← s.peek()
      // if right child exists and traversing node
      // from left child, then move right
      if (peekNode.right ≠ null and lastNodeVisited ≠ peekNode.right)
        node ← peekNode.right
      else
        visit(peekNode)
        lastNodeVisited ← s.pop()
```

**When considering a node**
* null
* not null
	* has 0 subtree
	* has 1 subtree
	* has 2 subtrees

## Breadth First Search ##

```
bfs(root):
  root -> queue
  while queue is not empty
    node = queue.poll()
    access(node)
    add all node.subnode -> queue
```

# Heap #

A heap is a specialized tree-based data structure that satisfies the heap property: If A is a parent node of B then the key of node A is ordered with respect to the key of node B with the same ordering applying across the heap.

- Min-Heap − where the value of root node is less than or equal to either of its children.
- Max-Heap − where the value of root node is greater than or equal to either of its children.

Construction -> **Bubble Sort**

Max Heap Assertion

```
Step 1 − Create a new node at the end of heap.
Step 2 − Assign new value to the node.
Step 3 − Compare the value of this child node with its parent.
Step 4 − If value of parent is less than child, then swap them.
Step 5 − Repeat step 3 & 4 until Heap property holds.
```

Max Heap Deletion

```
Step 1 − Remove root node.
Step 2 − Move the last element of last level to root.
Step 3 − Compare the value of this child node with its parent.
Step 4 − If value of parent is less than child, then swap them.
Step 5 − Repeat step 3 & 4 until Heap property holds.
```

http://www.tutorialspoint.com/data_structures_algorithms/heap_data_structure.htm
